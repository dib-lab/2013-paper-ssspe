%% Editorial Revision Requests:
%% A deeper exploration of the Khmer lifecycle, as noted by the reviewer, would
%% strengthen the paper

%% Additional major revisions as noted by the reviewer
%% should be considered optional, but the paper's discussion of the khmer
%% lifecycle and its ``growing pains'' would better adjust it to fit with the
%% collection

%% Minor revisions:
%% Some reordering of discussion
%% Extension of the abstract
%% Additional citations as noted in reviewer comments

%% 'detailed and deeper information about the tool’s growth such as users, 
%% communities, usage statistics, effort areas would be interesting and 
%% informative'

% 'the language of the paper feels too informal and should be improved.
% Colloquialisms should be avoided such as: ``bioinformaticians invent a
% new format every 5 minutes on average''


\documentclass[12pt]{article}
\usepackage{simplemargins}
\usepackage{times}
\usepackage{graphicx}
\usepackage[small,compact]{titlesec}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{paralist}
\fancypagestyle{firststyle}{%
  \fancyhf{}% Clear header/footer
  \fancyhead[L]{Experience Report}
}
\pagestyle{empty}

\date{April 2014}


\setlength{\parindent}{0pt}
\setlength{\parskip}{0.70ex}
\setallmargins{1in}
\title{Walking the talk: adopting and adapting sustainable scientific software
  development processes in a small biology lab.}

\author{Michael R. Crusoe$^{1}$\\
C. Titus Brown$^{2,1\ast}$\\
\small \bf{1} Microbiology and Molecular Genetics,\\
\small \bf{2} Computer Science and Engineering,\\
\small Michigan State University, East Lansing, MI, USA\\
\small $\ast$ Corresponding author: ctb@msu.edu}

\begin{document}
\maketitle
\thispagestyle{firststyle}

\abstract{The khmer software project\cite{khmer} implements both research and
  production functionality for large-scale nucleic-acid sequence analysis.  The
  project is driven by a small lab with only one
  full-time developer (MRC), as well as several graduate students and
  a professor (CTB) who contribute regularly to research features.
  Here we describe our efforts to bring better design, testing, and
  more open development to the khmer software project (which has
  just released version 1.0).}

%% Abstract seems rather terse. The three sentence abstract is rather too short
%% for a journal publication. Would be helpful to have a couple more sentences
%% there. Avoid usage of acronyms in abstract. (reviewer B)

%% MRC sees the story in this paper as: we measured our sustainability, took
%% measures to improve it and measured again. Our lives are better for it and
%% so is the project. List of details within.


\setlength{\parindent}{0pt}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.70ex}

\section{Introduction}

%% Does the paper understand and recognize other efforts in the area in order
%% to frame the discussion?
%% Reviewer B: No.
%% Reviewer C: Yes. In particular section 3 –use of the SSI evaluation
%% criteria. Was quite interested in coding styles adopted for python and C+  

%% Does the paper summarize the experiences of the authors, including
%% reflection on the importance of the arguments and conclusions?
%% Reviewer B: Partially.
%% Reviewer C: Yes

%% Is the paper written for a general research audience?
%% Reviewer B: No.
%% Reviewer C: Yes.

% Hard to judge from the introduction what has been done in the paper.
% Introduction seems a bit detached from the rest of the paper.

% "Citing the summary report of the WSSSPE1 (arxiv.org/abs/1404.7414) suggested
% as it touches many aspects covered in the present paper."

Computational tools for analyzing large volumes of DNA/RNA sequencing data
have become increasingly necessary over the last decade.  The growth
of sequencing capacity and the associated expansion of scientific
problems being studied with sequencing is driving the rapid development of
many new tools, both for handling data on large scales and to address
new and different biological problems.

The khmer software was born from a need to more scalably analyze short
fixed-length (20-30 character) words, or ``k-mers'', in large DNA sequencing data
sets. The use of k-mers in DNA sequence analysis is common because
they can be easily hashed, counted, and compared within and between
data sets.  However, as data sets have grown in size, approaches to
analyzing k-mers have fallen behind the memory and compute scaling curves. 
khmer provides several research and production functions:
approximate k-mer counting using a CountMin Sketch~\cite{Zhang2013},
an implementation of a compressible k-mer connectivity graph~\cite{Pell2012},
and a streaming lossy compression algorithm for large data
sets~\cite{Brown2012}.

We have developed the khmer software as an open source project since
the beginning: the software is under the BSD license, and we use
GitHub for development, code review, release tagging, and other
development activities.  We make a wide variety of tutorials and
user documentation available, as part of the khmer project itself and
also as part of a range of workshops.  Adoption of khmer is driven not only by
its utility in addressing otherwise difficult or intractable problems,
but also by CTB's blogging, research preprints and publications, and
presentations.  We now estimate that we have over 500 users of the
khmer software itself, and the algorithms and approaches initially
implemented in khmer have been adapted to and incorporated in several other
software packages.
% @ctb, what is the 500 user estimate based on?
% What is the feedback from the users: don’t hear from them; they cite us when it works

Our main challenge in developing khmer has been to build a stable and
reliable software project while simultaneously supporting an energetic
research program in bioinformatics.  This has traditionally been hard
for small scientific labs due to many factors including
lack of expertise and lack of sustained funding.  Below, we discuss
our experience in navigating a course towards a sustainable small-lab
software project.

\section{Background}

khmer grew out of specific analysis needs, and was developed primarily
on startup funding and as part of a USDA grant.  Its development has
led to at least two additional grants including the NIH BIG DATA
grant that now supports MRC~\cite{brown2012bigdata}.  Over its lifetime
khmer has had 15 different contributors, with five currently active.
The code consists of approximately 12.2k lines of C and C++ code, with
scripts and tests written in Python (6.6k lines of code).

The software was initially written by CTB for other purposes during
his graduate work at Caltech, and then extended so far as to be almost
entirely rewritten for research in his faculty position at Michigan
State University.  By July of 2013, when MRC started, the software had
its current level of functionality, but we faced a number of specific
challenges.

\begin{itemize}
\item First, we had no formal development model: no code review, no
  formatting requirements, no continuous integration, and no API
  stability requirements.  As a result we were constantly in a
  state of uncertainty about khmer's quality.

\item Second, our developers have a variety of experience: some were
  expert computational biologists with little to no programming
  experience, while others were experienced open source software
  developers with little to no computational biology background.  This
  meant that we could not confidently rely on good domain
  understanding {\em and} good software development hygiene from any
  one developer.

\item Third, like many bioinformatics projects, khmer is both {\em
  research} and {\em production} software: our lab is constantly
  extending khmer in new directions, at the same time as we and others
  apply its existing functionality to pressing biology research
  problems. While managing regular change is a traditional challenge
  for software development on long-running projects, the problem was
  exacerbated here because long-term planning was impractical given
  the high rate of technical innovation in sequencing data generation.

\item Fourth, khmer exists within an ecosystem of tools. khmer itself
  primarily acts as a filter for sequence data, which is generated in
  particular formats by upstream tools and is then consumed in those
  same formats by downstream tools.  We had no systematic testing of
  khmer within its larger ecosystem, and generally had to be alerted
  to such problems by users.

\end{itemize}

Collectively these challenges made us believe that khmer software
development was not sustainable without significant investment in
software engineering. Either \begin{inparaenum}[(1)] the research development
would falter in the face of increasingly high maintenance demands, or \item
khmer's stable functionality would start to deteriorate, or \item
both\end{inparaenum}.  To address these
challenges, CTB secured three years of NIH funding through the 2012
BIG DATA competition, and hired a software developer who also had a biology
education and bioinformatics experience, MRC\@

%% @CTB
%% "How are the challenges described in 1 and 2 were manifested in reality?
%% What were the causes?'' (reviewer B)

% What are the design bugs that have emerged? 
% Threading is hard. Sig refactoring needed to support planned uses. Hard to migrate to Python 3.x

% Python wrapped C++ is complicated to deploy across the variety of Linux and OS X versions

% Implementation bugs? 
% Many minor ones caught by increasing functional tests, integration tests, and users.

% What are the vertical and horizontal growth points?
% Vertical = tackling a single problem -> khmer protocols
% Horizontal -> expand beyond assembly? Yes, but not beyond sequence analysis

%Specific plans for khmer's future development include significant
%improvements in its processing efficiency
%\cite{DBLP:journals/corr/abs-1303-2223}, the implementation of novel
%algorithms for scaling \cite{brown2012CAREER}, the implementation of
%specific novel algorithms for data-driven biological discovery
%\cite{brown2012bigdata} integration with existing pipelines and user
%interfaces \cite{brown2009USDA} \cite{brown2012bigdata}, and the
%extension of khmer as a general research platform for rapid
%exploratory development of novel substring approaches to biological
%data analysis.

\section{Initial Evaluation}

To guide our development of a rational software development process,
we applied the Software Sustainability Institute's Criteria-based
assessment checklist~\cite{SSI-eval-guide} to the khmer project in
September 2013 and shared the results with the
community~\cite{khmer-assessment}. The summary from that report was grim: khmer
met 19 of 44 (or 43\%) of of the SSI's criteria for Usability, and 43
of 118 (or 36\%) of the criteria for Sustainability \& Maintainability, for an 
overall fulfillment of 62 of the 163 items, or 38\%.

% @CTB: could @MRC sprinkle in some details about what wasn't met, that
% is now met by the criteria below?

The low fulfillment of the SSI's criteria was slightly embarrassing for
the group for several reasons: CTB is a collaborator and co-author
with SSI;\@ quotes from him are featured in case study
presentations~\cite{SSI-casestudies}; he is cited as someone who is doing things
the correct way~\cite{SSI-recomputation}; and he regularly criticizes the
field for poor software process.  This is the point, however: because
these goals were highly valued within the lab, and because the
software filled a novel niche, CTB successfully argued for resources
to address these issues~\cite{khmer-future}.  Making significant
progress towards these ends isn't merely a matter of budgets and
hiring: even with a full time hybrid software
engineer/bioinformatician on the team it is not straightforward to
prioritize infrastructure work, let alone navigate between the core
research work, user support, community engagement, and collaborations.

% @CTB more here.

% ``one would expect more details. The description of Khmer's lifecycle looks 
% interesting but very brief and leaves reader high and dry in the end. Expand
% acronyms on first appearance. Second paragraph in [this section] reads a bit 
% awkward. Mostly colloquialism and anecdotal, even with an experience paper, 
% the language looks unsettled.''


%Our guiding principle, as eloquently put by MRC's first mentor, is
%``What is best for science?'' \cite{Nagy2007}. The (re)usability of
%khmer suite by others and the group's own ability to continue to
%extend and innovate with the codebase were two concrete areas of
%concern. On the usability front the most pressing issue was the
%lack of versioned releases and the fragility of the complicated build
%procedure due to a mixture of C++, C, and Python.  There was an
%existing body of tests but we did not know how well they cover the C++
%code.  Moreover, there was no regular continuous integration (automated
%extension of the existing tests as code is committed).

\section{Releasing version 1.0}

% ``Much of section 4 repeats standard software development and engineering
% practices, consider condensing some of the paragraphs in section 4.1-4.6''
% (reviewer B)

On April 1st, 2014, we released khmer 1.0.  While by no means a finished
product, we believe we are on a much more sustainable development path as khmer
now meets 69\% of the Software Sustainability Institute's checklist
\cite{khmer-1.0-assessment}.

For version 1.0, we added continuous integration, semantic versioning,
acceptance testing, development standards, code coverage analysis,
explicit citation information, and code review, among other process
alterations and features.  Below, we discuss these in more detail.

\subsection{Development standards and semantic versioning}

We instituted a number of development standards, including coding
styles and versioning requirements for backwards compatibility.  Our
goal was to have explicit written requirements that would inform new
contributors of our expectations, whether they have significant prior
programming experience or not.

Uniformity of coding styles helps maintain code readability and
enables easier code review, so we chose a coding style standard for
both C++ and Python. The specific choice for coding style was made
somewhat arbitrarily, largely to avoid protracted bikeshedding
discussions: the important goal was to have {\em some} coding standard. For
C++, we chose the ``One True Brace Style'' and the Artistic
Style program for indentation and bracing.  For Python, we settled on the default
PEP8 standard, for which several checking and reformatting tools
exist.

We also imposed a backwards compatibility requirement on our command
line scripts.  While we did not want to stabilize the Python or C++
API because we are actively changing khmer internals, we felt that
our command line scripts were sufficiently stable to require no
backwards-incompatible changes on the 1.0 series of releases.

We have therefore committed to {\em semantic versioning}\cite{semver} for the
command line scripts that come with khmer.  This imposes a
three-tiered versioning system: for patch version number changes
(khmer v1.0.x), only minor bug fixes and documentation updates are
allowed; for minor version number changes (khmer v1.x), backwards
compatibility of the command line scripts must be maintained; and,
should we choose to break backwards compatibility, we would need to
make a major version number change (khmer v2).

The importance of semantic versioning is that it allows developers,
documentation writers, sysadmins, and package managers to predict the
specific behavior from a range of versions, and to easily determine
whether or not they should upgrade their installation.  Of particular
importance, pipeline developers and users can rely on stable behavior
from minor releases.  We expect this to make khmer a more reliable
member of the sequencing analysis software ecosystem.

\subsection{Continuous integration}

Continuous integration ensures that automated tests are executed
regularly on standard platforms.  While developers are expected to
commit code with no failing tests, often they do not have convenient
access to all of the supported platforms and installation
environments.  Continuous integration frees individual developers from
having to execute their tests manually across many environments by
automating the entire process on commit.  Our continuous integration
system, built on top of Jenkins and running on a Rackspace donated
Linux server and an internal Mac OS X machine, also runs style
checkers and reports code coverage summaries.

The most important application of continuous integration for us has
been automated checking of merge requests prior to code review or
merge into the mainline.  This automatically ensures a basic quality
of committed code and also alerts developers to any platform
incompatibilities before they merge.

% @cite chapter on CI.

\subsection{Integrated code coverage analysis}

Code coverage analysis is an important part of software development:
statement coverage, or how many lines of code are executed in some way
by unit and functional tests, can readily identify untested regions of
code.\footnote{Note that while executed code is not guaranteed to be
  correct, code that is not executed by tests is certainly not tested,
  so high code coverage is a necessary but not sufficient condition
  for thorough testing.}  While khmer had several hundred tests by the
time MRC started working with it, the tests were all at the Python
level and we had no estimate of how well they covered the C++ code
base.

% Reviewer B: `` Footnote 1 can be merged into main text.''

Combined C++ and Python code coverage was instituted in October 2013
and we were pleasantly surprised to find that over 80\% of the khmer
codebase was executed in the tests.  Since October we have increased
the code coverage percentage to over 90\%. This number is now
calculated on every pull request (see below) and significant decreases
are flagged as ``unhealthy'' in our continuous integration system.

% ``How was this measured? Also, it is not an important measure. A more
% important measure is how many function points were tested? or what number of
% functionalities are covered by these tests.

\subsection{Code contribution process and code review}

While code review is an important part of ensuring that only ``good''
code and feature are included in a project, it is typically very time
consuming to do systematic code reviews.  In order to scale our
development process to more contributors while enabling code review,
we adopted the ``GitHub Flow'' model of code review~\cite{GitHubFlow}.
In this model, changes are developed on an independent branch
of code; this branch of code is linked to the main development
repository via a ``pull request'', which is an ongoing summary of
changes together with free text discussion.  When the developer feels
that the changes are ready to be merged, they request a formal review,
for which we have instituted a checklist; this checklist includes test
coverage and coding style analysis, documentation review, and
compatibility checking.

Our expectation is that this more formal but still lightweight
development process will encourage contributions and also serve as a
training and education process for less experienced developers.  By
making our developer contribution requirements explicit, we may also
serve as a guide for other bioinformatics software projects.

%\subsection{Unified build system}

%Pip installable.

\subsection{Citation information}

% @ctb: it was suggested that we move this subsection to the end. MRC agrees 

Scientific funding for software maintenance depends on demonstrating
the scientific utility of software; this is typically done via
citations.  For both algorithms and software, citations demonstrate
usage, utility, and impact.  However, scientific software may contain
multiple novel algorithms, and the software itself may be published
separately from the proof of concept of the algorithms.  For khmer,
this is a serious concern: we have publications or preprints on three
novel approaches implemented in khmer, and we are also continually
updating the software itself.  We also have a significant online
presence. This demonstrably confuses users: we have observed citations
of the incorrect paper for the algorithm being used, citations of our
documentation, and (oddly enough) citations of khmer documentation
hosted on other institutions' Web sites.

To clarify and regularize citation practices, we added explicit
citation guidelines in two places: first, in the CITATION file at the
top of the distribution, and second, in the output from every script.
We now ask that users cite not only the software itself (via a
software paper), but also the algorithm papers relevant to the
software features being used.

While we worry about appearing to be ``citation greedy\,'' we also
believe quite strongly that our ongoing efforts to maintain the
software are a critical part of our research, and that the researchers
and developers involved in that effort should be acknowledged
appropriately in the scientific literature.  This can really only be
addressed by requiring citation of the relevant software paper, which
will be updated for every significant version release with contributor
names.  At the same time, we also believe that our algorithm
contributions are independently important and should be acknowledged
by citations.  Hence, the requirement that when our algorithms are
used, the relevant algorithms paper should be cited.

\subsection{Integration and acceptance testing}

An ongoing concern for khmer is how well our software integrates with
other packages.  Because khmer primarily consumes the output of
upstream software, and the output of khmer is then fed into downstream
software, we need to take into account a larger software ecosystem.
Unfortunately, there are few real data format standards in this area:
the sequencing companies that generate the source data are notoriously
quick to change their output formats in arbitrary ways, and developers
of other packages may introduce format changes intentionally (through
feature extension) or unintentionally (through bugs).  Standardization
itself is probably a futile approach: while we expect A, C, G, and
T to remain the primary characters in DNA sequence representations,
the formats for data uncertainty and annotation evolve with
sequencing technology, which in turn is changing quickly.

We therefore have instituted {\em acceptance testing} to ensure that
khmer works with at least some upstream and downstream software
packages.  Our acceptance tests for khmer 1.0 take a subset of data
through quality control, error trimming, digital normalization, and
assembly; at the end we check that we obtain approximately the
expected results, vice minor details that change with different
versions of external software.  We have been greatly aided in
developing acceptance tests by our standard ``protocols'' for sequence
analysis: our acceptance tests go through the first three parts of the
Eel Pond mRNAseq protocol (http://khmer-protocols.readthedocs.org/).

Acceptance testing proved to be extremely important in the release
process.  Four different bugs having to do with installation and
command-line parameter handling were discovered in the 48 hours before
release; these bugs generally had to do with common command line cases
that were not readily testable at the unit and functional level.

We are also maintaining our acceptance tests for Ubuntu 12.04, a Long
Term Support version of Linux that will be supported through 2017.
This should further decrease maintenance efforts for our acceptance
tests.

\section{Persistent Challenges in Research Software Development}

In the long term, we expect to face three major challenges in continuing
to develop khmer.

First, we need to secure continued funding for khmer software
development.  This will depend primarily on producing novel research,
but a substantial part of our research is tied to khmer.  If we can
leverage our good software engineering practices to accelerate our own
research while also providing value to the larger community ---
``better science through superior software'' --- then arguments for more
funding will be much easier than if we simply develop khmer for
others to use.  This is less satisfying than getting funding for maintenance,
but is a more plausible path forward than relying on maintenance grants.

Second, we must balance maintenance activites with novel research
features.  In the face of changing input data (due to instrument and
experimental protocol changes), different expectations for output
(bioinformaticians invent a new format every 5 minutes on average),
competing algorithms with poor replicability, etc., we could spend
100\% of our time on quality control without developing anything new.
Maintenance could be a valuable community service but would not address
as many student, postdoc, or faculty career incentives as doing new
research.  Equally, expanding our research alone would result in less
reliable software.  Much of our process is dedicated to walking the
line between maintenance and novel research.

Third, we face many challenges in terms of recruiting software
developers and researchers.  Inevitably new lab members are
undertrained in most of what we do, including testing, version
control, good computational hygiene, data science, bioinformatics
and/or the domain of biology.  These are a lot of subjects to train
new people in, and we have yet to establish an effective lab culture.
On the converse side, of course, we expect lab graduates to be
increasingly employable in both academia and biotech; moreover, the
lab reputation of caring about good software has started to attract
people with deeper training.

\section{Concluding thoughts}

% ``Future of the tool should have been discussed in much more depth and detail
% than is currently``

% “Consider using bold or italics to highlight main conclusions - helps someone
% skimming this section.”

While we are still at the early stages of the experiment, we believe
we can reach some conclusions about which parts of our process have
been most important.  While these are anecdotes, most of our process
is already standard in both industry and open source projects, so we
would argue that our anecdotes bear out what is already known outside
of scientific research.

First, we believe that version control and significant automated
testing have both been incredibly important and are absolutely
necessary for any sustained software development effort.  Without
version control, having multiple developers work on the same project
would have been effectively impossible: all our time would have been
spent on coordination issues.  Even with a single developer (CTB),
khmer development benefited from version history and source code
comparison across versions.

Without automated testing, we would almost certainly have hesitated to
make many changes, for fear of introducing regressions; this is
especially important given the variance in software engineering
expertise.  By insisting that new code have tests associated with it,
we also ensured that other developers would avoid unintentionally breaking
new code they were not yet familiar with.

Second, acceptance testing has proven quite valuable for 1.0.  Prior
to committing to a stable command-line API, acceptance testing would
most likely have been a waste of time: maintenance effort would have
been needed to keep the scripts and tutorials working well together.
However, now that we have committed to a stable command-line API, if
the acceptance tests break it will be a bug, so there should be little
maintenance burden.  By committing to an Ubuntu Long Term Support
release for running the acceptance tests, we can further control our
maintenance costs.

Third, as we expand our development team and encourage contributions
from people external to our lab, automated ways of evaluating software
quality become extremely useful.  Here, continuous integration, style
checks, and code coverage analysis are particularly important for
maintaining project stability.  A formal code review by an experienced
developer is the enforcement mechanism that ensures that basic requirements
are met.

One important caveat is that we don't yet know how well any of this is
going to work!  Our chief goals are to enable further research with
khmer and maintain existing functionality, all while our
developer base expands and/or turns over. We hope and believe that our
approaches will let us do this, but we need a longer baseline of
observations to find out.


%CTB: The two primary challenges are cultural (which was expected) and
%technical (which was unexpected).  By cultural, I mean that there is
%virtually no culture of computational reproducibility or software
%development in biology, which makes it hard to discuss much less
%justify.  Technically, the infrastructure and tools for enabling
%reproducibility are still quite young and do not fit the needs of
%subdomains terribly well.  For example, I thought that other fields
%would have tools for provenance and workflow tracking that we could
%easily adapt; this is simply not the case.  In fact, our most effective set
%of tools has emerged from open source and data science work, including
%the excellent Python and GitHub communities, IPython Notebook, and
%cloud computing infrastructure.

%[et cetera]

%[Summary & conclusion]

% @talk about importance of software; novelty squared.

% future plans?

\section*{Acknowledgments}

MRC has been funded by AFRI Competitive Grant no. 2010-65205-20361
from the USDA NIFA and is now funded by the National Human Genome
Research Institute of the National Institutes of Health under Award
Number R01HG007513; both to C. Titus Brown.  We thank Dr.\ Lex
Nederbragt for helpful comments on early drafts.

\bibliographystyle{plain}
\bibliography{wssspe13-ged}


%"Open Call for Projects" http://www.software.ac.uk/open-call

%Wilson, G., Aruliah, D.A.,Titus Brown, C.T., Chue Hong, N. P., Davis, M., Guy, R. T., Haddock, S.H.D, Huff, K., Mitchell, I.M., Plumbley, M., Waugh, B., White, E. P. and Wilson, P. Best Practices for Scientific Computing. CoRR, arXiv:1210.0530 [cs.MS], 2012.

%"The five stars of research software" http://www.software.ac.uk/blog/2013-04-09-five-stars-research-software

%"Issues ged-lab/khmer" https://github.com/ged-lab/khmer/issues?direction=desc&milestone=1&page=1&sort=updated&state=open

\end{document}
